
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections.Tests/FixedListTests.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using NUnit.Framework;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Collections.Tests;
#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
using UnityEngine;
#endif

internal class FixedListTests : CollectionsTestFixture
{
    struct NonComparableStruct
    {
        public int a;
    }

    struct DescendingComparer<T> : IComparer<T> where T : IComparable<T>
    {
        public int Compare(T x, T y) => y.CompareTo(x);
    }

    [Test]
    [IgnoreInPortableTests("Crashes in IL2CPP on unsupported feature.")]
    public void FixedList32DebugView()
    {
        var list = new FixedList32<NonComparableStruct>();
        CollectionAssert.IsEmpty(new FixedList32DebugView<NonComparableStruct>(list).Items);

        var reference = new []
        {
            new NonComparableStruct{ a = 123 },
            new NonComparableStruct{ a = 234 },
            new NonComparableStruct{ a = 345 },
        };

        list.Add(reference[0]);
        list.Add(reference[1]);
        list.Add(reference[2]);

        CollectionAssert.AreEqual(reference, new FixedList32DebugView<NonComparableStruct>(list).Items);
    }

    [Test]
    [IgnoreInPortableTests("Crashes in IL2CPP on unsupported feature.")]
    public void FixedList64DebugView()
    {
        var list = new FixedList64<NonComparableStruct>();
        CollectionAssert.IsEmpty(new FixedList64DebugView<NonComparableStruct>(list).Items);

        var reference = new []
        {
            new NonComparableStruct{ a = 123 },
            new NonComparableStruct{ a = 234 },
            new NonComparableStruct{ a = 345 },
        };

        list.Add(reference[0]);
        list.Add(reference[1]);
        list.Add(reference[2]);

        CollectionAssert.AreEqual(reference, new FixedList64DebugView<NonComparableStruct>(list).Items);
    }

    [Test]
    [IgnoreInPortableTests("Crashes in IL2CPP on unsupported feature.")]
    public void FixedList128DebugView()
    {
        var list = new FixedList128<NonComparableStruct>();
        CollectionAssert.IsEmpty(new FixedList128DebugView<NonComparableStruct>(list).Items);

        var reference = new []
        {
            new NonComparableStruct{ a = 123 },
            new NonComparableStruct{ a = 234 },
            new NonComparableStruct{ a = 345 },
        };

        list.Add(reference[0]);
        list.Add(reference[1]);
        list.Add(reference[2]);

        CollectionAssert.AreEqual(reference, new FixedList128DebugView<NonComparableStruct>(list).Items);
    }


    [Test]
    public void FixedList32byteToNativeArrayWorks()
    {
        var list = new FixedList32<byte>();

        for(var i = 0; i < 30; ++i)
            list.Add((byte)(i * 123 + 234));

        using(var array = list.ToNativeArray(Allocator.Temp))
        {
            for(var i = 0; i < 30; ++i)
                Assert.AreEqual((byte)(i * 123 + 234), array[i]);
        }
    }

    [Test]
    public void FixedList32byteGenericHasExpectedLayout()
    {
        var actual = new FixedList32<byte>();
        for(var i = 0; i < 30; ++i)
          actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((30 >> 0) & 0xFF);
            e[1] = (byte)((30 >> 8) & 0xFF);
            for(var i = 0; i < 30; ++i)
            {
              var s = (byte)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedList32byteGenericHasExpectedCapacity()
    {
        var list = new FixedList32<byte>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((byte)expectedCapacity); });
    }
    [Test]
    public void FixedList32byteGenericInsertRangeWithBeginEnd()
    {
        var list = new FixedList32<byte>() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericRemoveRangeWithBeginEnd()
    {
        var list = new FixedList32<byte>() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericInsert()
    {
        var list = new FixedList32<byte>() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericRemoveAt()
    {
        var list = new FixedList32<byte>() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericRemove()
    {
        var list = new FixedList32<byte>() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove((byte)3));
        Assert.True(list.Remove((byte)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericRemoveSwapBack()
    {
        var list = new FixedList32<byte>() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack((byte)3));
        Assert.True(list.RemoveSwapBack((byte)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericSort()
    {
        var list = new FixedList32<byte>();
        for(var i = 0; i < 5; ++i)
          list.Add((byte)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericSortCustomComparer()
    {
        var list = new FixedList32<byte>();
        for(var i = 0; i < 5; ++i)
          list.Add((byte)(i));
        list.Sort(new DescendingComparer<byte>());
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(4-i, list[i]);
    }

    [Test]
    public unsafe void FixedList32byteIndexOf()
    {
        var list = new FixedList32<byte>() { 123, 178 };
        bool r0 = false, r1 = false, r2 = false;

        GCAllocRecorder.ValidateNoGCAllocs(() =>
        {
            r0 = -1 != list.IndexOf((byte)145);
            r1 = list.Contains((byte)123);
            r2 = list.Contains((byte)178);
        });

        Assert.False(r0);
        Assert.True(r1);
        Assert.True(r2);
    }


    [Test]
    public void FixedList64byteToNativeArrayWorks()
    {
        var list = new FixedList64<byte>();

        for(var i = 0; i < 62; ++i)
            list.Add((byte)(i * 123 + 234));

        using(var array = list.ToNativeArray(Allocator.Temp))
        {
            for(var i = 0; i < 62; ++i)
                Assert.AreEqual((byte)(i * 123 + 234), array[i]);
        }
    }

    [Test]
    public void FixedList64byteGenericHasExpectedLayout()
    {
        var actual = new FixedList64<byte>();
        for(var i = 0; i < 62; ++i)
          actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((62 >> 0) & 0xFF);
            e[1] = (byte)((62 >> 8) & 0xFF);
            for(var i = 0; i < 62; ++i)
            {
              var s = (byte)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedList64byteGenericHasExpectedCapacity()
    {
        var list = new FixedList64<byte>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((byte)expectedCapacity); });
    }
    [Test]
    public void FixedList64byteGenericInsertRangeWithBeginEnd()
    {
        var list = new FixedList64<byte>() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericRemoveRangeWithBeginEnd()
    {
        var list = new FixedList64<byte>() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericInsert()
    {
        var list = new FixedList64<byte>() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericRemoveAt()
    {
        var list = new FixedList64<byte>() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericRemove()
    {
        var list = new FixedList64<byte>() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove((byte)3));
        Assert.True(list.Remove((byte)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericRemoveSwapBack()
    {
        var list = new FixedList64<byte>() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack((byte)3));
        Assert.True(list.RemoveSwapBack((byte)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericSort()
    {
        var list = new FixedList64<byte>();
        for(var i = 0; i < 5; ++i)
          list.Add((byte)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericSortCustomComparer()
    {
        var list = new FixedList64<byte>();
        for(var i = 0; i < 5; ++i)
          list.Add((byte)(i));
        list.Sort(new DescendingComparer<byte>());
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(4-i, list[i]);
    }

    [Test]
    public unsafe void FixedList64byteIndexOf()
    {
        var list = new FixedList64<byte>() { 123, 178 };
        bool r0 = false, r1 = false, r2 = false;

        GCAllocRecorder.ValidateNoGCAllocs(() =>
        {
            r0 = -1 != list.IndexOf((byte)145);
            r1 = list.Contains((byte)123);
            r2 = list.Contains((byte)178);
        });

        Assert.False(r0);
        Assert.True(r1);
        Assert.True(r2);
    }


    [Test]
    public void FixedList128byteToNativeArrayWorks()
    {
        var list = new FixedList128<byte>();

        for(var i = 0; i < 126; ++i)
            list.Add((byte)(i * 123 + 234));

        using(var array = list.ToNativeArray(Allocator.Temp))
        {
            for(var i = 0; i < 126; ++i)
                Assert.AreEqual((byte)(i * 123 + 234), array[i]);
        }
    }

    [Test]
    public void FixedList128byteGenericHasExpectedLayout()
    {
        var actual = new FixedList128<byte>();
        for(var i = 0; i < 126; ++i)
          actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((126 >> 0) & 0xFF);
            e[1] = (byte)((126 >> 8) & 0xFF);
            for(var i = 0; i < 126; ++i)
            {
              var s = (byte)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedList128byteGenericHasExpectedCapacity()
    {
        var list = new FixedList128<byte>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((byte)expectedCapacity); });
    }
    [Test]
    public void FixedList128byteGenericInsertRangeWithBeginEnd()
    {
        var list = new FixedList128<byte>() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericRemoveRangeWithBeginEnd()
    {
        var list = new FixedList128<byte>() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericInsert()
    {
        var list = new FixedList128<byte>() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericRemoveAt()
    {
        var list = new FixedList128<byte>() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericRemove()
    {
        var list = new FixedList128<byte>() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove((byte)3));
        Assert.True(list.Remove((byte)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericRemoveSwapBack()
    {
        var list = new FixedList128<byte>() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack((byte)3));
        Assert.True(list.RemoveSwapBack((byte)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericSort()
    {
        var list = new FixedList128<byte>();
        for(var i = 0; i < 5; ++i)
          list.Add((byte)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericSortCustomComparer()
    {
        var list = new FixedList128<byte>();
        for(var i = 0; i < 5; ++i)
          list.Add((byte)(i));
        list.Sort(new DescendingComparer<byte>());
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(4-i, list[i]);
    }

    [Test]
    public unsafe void FixedList128byteIndexOf()
    {
        var list = new FixedList128<byte>() { 123, 178 };
        bool r0 = false, r1 = false, r2 = false;

        GCAllocRecorder.ValidateNoGCAllocs(() =>
        {
            r0 = -1 != list.IndexOf((byte)145);
            r1 = list.Contains((byte)123);
            r2 = list.Contains((byte)178);
        });

        Assert.False(r0);
        Assert.True(r1);
        Assert.True(r2);
    }


    [Test]
    public void FixedListByte32HasExpectedLayout()
    {
        var actual = new FixedListByte32();
        for(var i = 0; i < 30; ++i)
          actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((30 >> 0) & 0xFF);
            e[1] = (byte)((30 >> 8) & 0xFF);
            for(var i = 0; i < 30; ++i)
            {
              var s = (byte)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedListByte32HasExpectedCapacity()
    {
        var list = new FixedListByte32();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((byte)expectedCapacity); });
    }

#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
    class ScriptableObjectFixedListByte32 : UnityEngine.ScriptableObject
    {
        public FixedListByte32 List;
    }

    [Test]
    public void FixedListByte32Serializes()
    {
        var a = UnityEngine.ScriptableObject.CreateInstance<ScriptableObjectFixedListByte32 >();
        for(int i = 0; i < a.List.Capacity; ++i)
            a.List.Add((byte)i);
        var b = UnityEngine.Object.Instantiate(a);
        CollectionAssert.AreEqual(a.List, b.List);
    }
#endif

    [Test]
    public void FixedListByte32InsertRangeWithBeginEnd()
    {
        var list = new FixedListByte32() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListByte32 container, int expectedLength, int[] expected)
    {
        Assert.AreEqual(expectedLength == 0, container.IsEmpty);
        Assert.AreEqual(container.Length, expectedLength);
        for (var i = 0; i < container.Length; ++i)
        {
            Assert.AreEqual(expected[i], container[i]);
        }
    }

    [Test]
    public void FixedListByte32RemoveAt()
    {
        var list = new FixedListByte32() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte32Remove()
    {
        var list = new FixedListByte32() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove(3));
        Assert.True(list.Remove(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte32RemoveSwapBack()
    {
        var list = new FixedListByte32() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack(3));
        Assert.True(list.RemoveSwapBack(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte32RemoveRangeWithBeginEnd()
    {
        var list = new FixedListByte32() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte32RemoveAtSwapBack()
    {
        var list = new FixedListByte32() { 0, 3, 3, 1, 2 };
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListByte32RemoveRangeSwapBackWithBeginEnd()
    {
        var list = new FixedListByte32() { 0, 3, 3, 1, 2 };
        list.RemoveRangeSwapBackWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte32Insert()
    {
        var list = new FixedListByte32() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte32Sort()
    {
        var list = new FixedListByte32();
        for(var i = 0; i < 5; ++i)
          list.Add((byte)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte32ToFixedListByte64()
    {
        var a = new FixedListByte32();
        for(var i = 0; i < 30; ++i)
            a.Add((byte)i);
        var b = new FixedListByte64(a);
        for(var i = 0; i < 30; ++i)
            Assert.AreEqual((byte)i, b[i]);
    }
    [Test]
    public void FixedListByte32ToFixedListByte128()
    {
        var a = new FixedListByte32();
        for(var i = 0; i < 30; ++i)
            a.Add((byte)i);
        var b = new FixedListByte128(a);
        for(var i = 0; i < 30; ++i)
            Assert.AreEqual((byte)i, b[i]);
    }

    [Test]
    public void FixedListByte64HasExpectedLayout()
    {
        var actual = new FixedListByte64();
        for(var i = 0; i < 62; ++i)
          actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((62 >> 0) & 0xFF);
            e[1] = (byte)((62 >> 8) & 0xFF);
            for(var i = 0; i < 62; ++i)
            {
              var s = (byte)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedListByte64HasExpectedCapacity()
    {
        var list = new FixedListByte64();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((byte)expectedCapacity); });
    }

#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
    class ScriptableObjectFixedListByte64 : UnityEngine.ScriptableObject
    {
        public FixedListByte64 List;
    }

    [Test]
    public void FixedListByte64Serializes()
    {
        var a = UnityEngine.ScriptableObject.CreateInstance<ScriptableObjectFixedListByte64 >();
        for(int i = 0; i < a.List.Capacity; ++i)
            a.List.Add((byte)i);
        var b = UnityEngine.Object.Instantiate(a);
        CollectionAssert.AreEqual(a.List, b.List);
    }
#endif

    [Test]
    public void FixedListByte64InsertRangeWithBeginEnd()
    {
        var list = new FixedListByte64() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListByte64 container, int expectedLength, int[] expected)
    {
        Assert.AreEqual(expectedLength == 0, container.IsEmpty);
        Assert.AreEqual(container.Length, expectedLength);
        for (var i = 0; i < container.Length; ++i)
        {
            Assert.AreEqual(expected[i], container[i]);
        }
    }

    [Test]
    public void FixedListByte64RemoveAt()
    {
        var list = new FixedListByte64() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte64Remove()
    {
        var list = new FixedListByte64() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove(3));
        Assert.True(list.Remove(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte64RemoveSwapBack()
    {
        var list = new FixedListByte64() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack(3));
        Assert.True(list.RemoveSwapBack(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte64RemoveRangeWithBeginEnd()
    {
        var list = new FixedListByte64() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte64RemoveAtSwapBack()
    {
        var list = new FixedListByte64() { 0, 3, 3, 1, 2 };
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListByte64RemoveRangeSwapBackWithBeginEnd()
    {
        var list = new FixedListByte64() { 0, 3, 3, 1, 2 };
        list.RemoveRangeSwapBackWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte64Insert()
    {
        var list = new FixedListByte64() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte64Sort()
    {
        var list = new FixedListByte64();
        for(var i = 0; i < 5; ++i)
          list.Add((byte)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte64ToFixedListByte32()
    {
        var a = new FixedListByte64();
        for(var i = 0; i < 62; ++i)
            a.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException> (() => { var b = new FixedListByte32(a); } );
    }
    [Test]
    public void FixedListByte64ToFixedListByte128()
    {
        var a = new FixedListByte64();
        for(var i = 0; i < 62; ++i)
            a.Add((byte)i);
        var b = new FixedListByte128(a);
        for(var i = 0; i < 62; ++i)
            Assert.AreEqual((byte)i, b[i]);
    }

    [Test]
    public void FixedListByte128HasExpectedLayout()
    {
        var actual = new FixedListByte128();
        for(var i = 0; i < 126; ++i)
          actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((126 >> 0) & 0xFF);
            e[1] = (byte)((126 >> 8) & 0xFF);
            for(var i = 0; i < 126; ++i)
            {
              var s = (byte)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedListByte128HasExpectedCapacity()
    {
        var list = new FixedListByte128();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((byte)expectedCapacity); });
    }

#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
    class ScriptableObjectFixedListByte128 : UnityEngine.ScriptableObject
    {
        public FixedListByte128 List;
    }

    [Test]
    public void FixedListByte128Serializes()
    {
        var a = UnityEngine.ScriptableObject.CreateInstance<ScriptableObjectFixedListByte128 >();
        for(int i = 0; i < a.List.Capacity; ++i)
            a.List.Add((byte)i);
        var b = UnityEngine.Object.Instantiate(a);
        CollectionAssert.AreEqual(a.List, b.List);
    }
#endif

    [Test]
    public void FixedListByte128InsertRangeWithBeginEnd()
    {
        var list = new FixedListByte128() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListByte128 container, int expectedLength, int[] expected)
    {
        Assert.AreEqual(expectedLength == 0, container.IsEmpty);
        Assert.AreEqual(container.Length, expectedLength);
        for (var i = 0; i < container.Length; ++i)
        {
            Assert.AreEqual(expected[i], container[i]);
        }
    }

    [Test]
    public void FixedListByte128RemoveAt()
    {
        var list = new FixedListByte128() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte128Remove()
    {
        var list = new FixedListByte128() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove(3));
        Assert.True(list.Remove(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte128RemoveSwapBack()
    {
        var list = new FixedListByte128() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack(3));
        Assert.True(list.RemoveSwapBack(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte128RemoveRangeWithBeginEnd()
    {
        var list = new FixedListByte128() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte128RemoveAtSwapBack()
    {
        var list = new FixedListByte128() { 0, 3, 3, 1, 2 };
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListByte128RemoveRangeSwapBackWithBeginEnd()
    {
        var list = new FixedListByte128() { 0, 3, 3, 1, 2 };
        list.RemoveRangeSwapBackWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte128Insert()
    {
        var list = new FixedListByte128() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte128Sort()
    {
        var list = new FixedListByte128();
        for(var i = 0; i < 5; ++i)
          list.Add((byte)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte128ToFixedListByte32()
    {
        var a = new FixedListByte128();
        for(var i = 0; i < 126; ++i)
            a.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException> (() => { var b = new FixedListByte32(a); } );
    }
    [Test]
    public void FixedListByte128ToFixedListByte64()
    {
        var a = new FixedListByte128();
        for(var i = 0; i < 126; ++i)
            a.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException> (() => { var b = new FixedListByte64(a); } );
    }

    [Test]
    public void FixedList32intToNativeArrayWorks()
    {
        var list = new FixedList32<int>();

        for(var i = 0; i < 7; ++i)
            list.Add((int)(i * 123 + 234));

        using(var array = list.ToNativeArray(Allocator.Temp))
        {
            for(var i = 0; i < 7; ++i)
                Assert.AreEqual((int)(i * 123 + 234), array[i]);
        }
    }

    [Test]
    public void FixedList32intGenericHasExpectedLayout()
    {
        var actual = new FixedList32<int>();
        for(var i = 0; i < 7; ++i)
          actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((7 >> 0) & 0xFF);
            e[1] = (byte)((7 >> 8) & 0xFF);
            for(var i = 0; i < 7; ++i)
            {
              var s = (int)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedList32intGenericHasExpectedCapacity()
    {
        var list = new FixedList32<int>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((int)expectedCapacity); });
    }
    [Test]
    public void FixedList32intGenericInsertRangeWithBeginEnd()
    {
        var list = new FixedList32<int>() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericRemoveRangeWithBeginEnd()
    {
        var list = new FixedList32<int>() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericInsert()
    {
        var list = new FixedList32<int>() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericRemoveAt()
    {
        var list = new FixedList32<int>() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericRemove()
    {
        var list = new FixedList32<int>() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove((int)3));
        Assert.True(list.Remove((int)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericRemoveSwapBack()
    {
        var list = new FixedList32<int>() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack((int)3));
        Assert.True(list.RemoveSwapBack((int)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericSort()
    {
        var list = new FixedList32<int>();
        for(var i = 0; i < 5; ++i)
          list.Add((int)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericSortCustomComparer()
    {
        var list = new FixedList32<int>();
        for(var i = 0; i < 5; ++i)
          list.Add((int)(i));
        list.Sort(new DescendingComparer<int>());
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(4-i, list[i]);
    }

    [Test]
    public unsafe void FixedList32intIndexOf()
    {
        var list = new FixedList32<int>() { 123, 178 };
        bool r0 = false, r1 = false, r2 = false;

        GCAllocRecorder.ValidateNoGCAllocs(() =>
        {
            r0 = -1 != list.IndexOf((int)145);
            r1 = list.Contains((int)123);
            r2 = list.Contains((int)178);
        });

        Assert.False(r0);
        Assert.True(r1);
        Assert.True(r2);
    }


    [Test]
    public void FixedList64intToNativeArrayWorks()
    {
        var list = new FixedList64<int>();

        for(var i = 0; i < 15; ++i)
            list.Add((int)(i * 123 + 234));

        using(var array = list.ToNativeArray(Allocator.Temp))
        {
            for(var i = 0; i < 15; ++i)
                Assert.AreEqual((int)(i * 123 + 234), array[i]);
        }
    }

    [Test]
    public void FixedList64intGenericHasExpectedLayout()
    {
        var actual = new FixedList64<int>();
        for(var i = 0; i < 15; ++i)
          actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((15 >> 0) & 0xFF);
            e[1] = (byte)((15 >> 8) & 0xFF);
            for(var i = 0; i < 15; ++i)
            {
              var s = (int)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedList64intGenericHasExpectedCapacity()
    {
        var list = new FixedList64<int>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((int)expectedCapacity); });
    }
    [Test]
    public void FixedList64intGenericInsertRangeWithBeginEnd()
    {
        var list = new FixedList64<int>() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericRemoveRangeWithBeginEnd()
    {
        var list = new FixedList64<int>() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericInsert()
    {
        var list = new FixedList64<int>() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericRemoveAt()
    {
        var list = new FixedList64<int>() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericRemove()
    {
        var list = new FixedList64<int>() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove((int)3));
        Assert.True(list.Remove((int)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericRemoveSwapBack()
    {
        var list = new FixedList64<int>() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack((int)3));
        Assert.True(list.RemoveSwapBack((int)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericSort()
    {
        var list = new FixedList64<int>();
        for(var i = 0; i < 5; ++i)
          list.Add((int)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericSortCustomComparer()
    {
        var list = new FixedList64<int>();
        for(var i = 0; i < 5; ++i)
          list.Add((int)(i));
        list.Sort(new DescendingComparer<int>());
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(4-i, list[i]);
    }

    [Test]
    public unsafe void FixedList64intIndexOf()
    {
        var list = new FixedList64<int>() { 123, 178 };
        bool r0 = false, r1 = false, r2 = false;

        GCAllocRecorder.ValidateNoGCAllocs(() =>
        {
            r0 = -1 != list.IndexOf((int)145);
            r1 = list.Contains((int)123);
            r2 = list.Contains((int)178);
        });

        Assert.False(r0);
        Assert.True(r1);
        Assert.True(r2);
    }


    [Test]
    public void FixedList128intToNativeArrayWorks()
    {
        var list = new FixedList128<int>();

        for(var i = 0; i < 31; ++i)
            list.Add((int)(i * 123 + 234));

        using(var array = list.ToNativeArray(Allocator.Temp))
        {
            for(var i = 0; i < 31; ++i)
                Assert.AreEqual((int)(i * 123 + 234), array[i]);
        }
    }

    [Test]
    public void FixedList128intGenericHasExpectedLayout()
    {
        var actual = new FixedList128<int>();
        for(var i = 0; i < 31; ++i)
          actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((31 >> 0) & 0xFF);
            e[1] = (byte)((31 >> 8) & 0xFF);
            for(var i = 0; i < 31; ++i)
            {
              var s = (int)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedList128intGenericHasExpectedCapacity()
    {
        var list = new FixedList128<int>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((int)expectedCapacity); });
    }
    [Test]
    public void FixedList128intGenericInsertRangeWithBeginEnd()
    {
        var list = new FixedList128<int>() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericRemoveRangeWithBeginEnd()
    {
        var list = new FixedList128<int>() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericInsert()
    {
        var list = new FixedList128<int>() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericRemoveAt()
    {
        var list = new FixedList128<int>() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericRemove()
    {
        var list = new FixedList128<int>() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove((int)3));
        Assert.True(list.Remove((int)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericRemoveSwapBack()
    {
        var list = new FixedList128<int>() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack((int)3));
        Assert.True(list.RemoveSwapBack((int)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericSort()
    {
        var list = new FixedList128<int>();
        for(var i = 0; i < 5; ++i)
          list.Add((int)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericSortCustomComparer()
    {
        var list = new FixedList128<int>();
        for(var i = 0; i < 5; ++i)
          list.Add((int)(i));
        list.Sort(new DescendingComparer<int>());
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(4-i, list[i]);
    }

    [Test]
    public unsafe void FixedList128intIndexOf()
    {
        var list = new FixedList128<int>() { 123, 178 };
        bool r0 = false, r1 = false, r2 = false;

        GCAllocRecorder.ValidateNoGCAllocs(() =>
        {
            r0 = -1 != list.IndexOf((int)145);
            r1 = list.Contains((int)123);
            r2 = list.Contains((int)178);
        });

        Assert.False(r0);
        Assert.True(r1);
        Assert.True(r2);
    }


    [Test]
    public void FixedListInt32HasExpectedLayout()
    {
        var actual = new FixedListInt32();
        for(var i = 0; i < 7; ++i)
          actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((7 >> 0) & 0xFF);
            e[1] = (byte)((7 >> 8) & 0xFF);
            for(var i = 0; i < 7; ++i)
            {
              var s = (int)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedListInt32HasExpectedCapacity()
    {
        var list = new FixedListInt32();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((int)expectedCapacity); });
    }

#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
    class ScriptableObjectFixedListInt32 : UnityEngine.ScriptableObject
    {
        public FixedListInt32 List;
    }

    [Test]
    public void FixedListInt32Serializes()
    {
        var a = UnityEngine.ScriptableObject.CreateInstance<ScriptableObjectFixedListInt32 >();
        for(int i = 0; i < a.List.Capacity; ++i)
            a.List.Add((int)i);
        var b = UnityEngine.Object.Instantiate(a);
        CollectionAssert.AreEqual(a.List, b.List);
    }
#endif

    [Test]
    public void FixedListInt32InsertRangeWithBeginEnd()
    {
        var list = new FixedListInt32() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListInt32 container, int expectedLength, int[] expected)
    {
        Assert.AreEqual(expectedLength == 0, container.IsEmpty);
        Assert.AreEqual(container.Length, expectedLength);
        for (var i = 0; i < container.Length; ++i)
        {
            Assert.AreEqual(expected[i], container[i]);
        }
    }

    [Test]
    public void FixedListInt32RemoveAt()
    {
        var list = new FixedListInt32() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt32Remove()
    {
        var list = new FixedListInt32() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove(3));
        Assert.True(list.Remove(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt32RemoveSwapBack()
    {
        var list = new FixedListInt32() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack(3));
        Assert.True(list.RemoveSwapBack(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt32RemoveRangeWithBeginEnd()
    {
        var list = new FixedListInt32() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt32RemoveAtSwapBack()
    {
        var list = new FixedListInt32() { 0, 3, 3, 1, 2 };
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListInt32RemoveRangeSwapBackWithBeginEnd()
    {
        var list = new FixedListInt32() { 0, 3, 3, 1, 2 };
        list.RemoveRangeSwapBackWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt32Insert()
    {
        var list = new FixedListInt32() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt32Sort()
    {
        var list = new FixedListInt32();
        for(var i = 0; i < 5; ++i)
          list.Add((int)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt32ToFixedListInt64()
    {
        var a = new FixedListInt32();
        for(var i = 0; i < 7; ++i)
            a.Add((int)i);
        var b = new FixedListInt64(a);
        for(var i = 0; i < 7; ++i)
            Assert.AreEqual((int)i, b[i]);
    }
    [Test]
    public void FixedListInt32ToFixedListInt128()
    {
        var a = new FixedListInt32();
        for(var i = 0; i < 7; ++i)
            a.Add((int)i);
        var b = new FixedListInt128(a);
        for(var i = 0; i < 7; ++i)
            Assert.AreEqual((int)i, b[i]);
    }

    [Test]
    public void FixedListInt64HasExpectedLayout()
    {
        var actual = new FixedListInt64();
        for(var i = 0; i < 15; ++i)
          actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((15 >> 0) & 0xFF);
            e[1] = (byte)((15 >> 8) & 0xFF);
            for(var i = 0; i < 15; ++i)
            {
              var s = (int)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedListInt64HasExpectedCapacity()
    {
        var list = new FixedListInt64();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((int)expectedCapacity); });
    }

#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
    class ScriptableObjectFixedListInt64 : UnityEngine.ScriptableObject
    {
        public FixedListInt64 List;
    }

    [Test]
    public void FixedListInt64Serializes()
    {
        var a = UnityEngine.ScriptableObject.CreateInstance<ScriptableObjectFixedListInt64 >();
        for(int i = 0; i < a.List.Capacity; ++i)
            a.List.Add((int)i);
        var b = UnityEngine.Object.Instantiate(a);
        CollectionAssert.AreEqual(a.List, b.List);
    }
#endif

    [Test]
    public void FixedListInt64InsertRangeWithBeginEnd()
    {
        var list = new FixedListInt64() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListInt64 container, int expectedLength, int[] expected)
    {
        Assert.AreEqual(expectedLength == 0, container.IsEmpty);
        Assert.AreEqual(container.Length, expectedLength);
        for (var i = 0; i < container.Length; ++i)
        {
            Assert.AreEqual(expected[i], container[i]);
        }
    }

    [Test]
    public void FixedListInt64RemoveAt()
    {
        var list = new FixedListInt64() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt64Remove()
    {
        var list = new FixedListInt64() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove(3));
        Assert.True(list.Remove(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt64RemoveSwapBack()
    {
        var list = new FixedListInt64() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack(3));
        Assert.True(list.RemoveSwapBack(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt64RemoveRangeWithBeginEnd()
    {
        var list = new FixedListInt64() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt64RemoveAtSwapBack()
    {
        var list = new FixedListInt64() { 0, 3, 3, 1, 2 };
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListInt64RemoveRangeSwapBackWithBeginEnd()
    {
        var list = new FixedListInt64() { 0, 3, 3, 1, 2 };
        list.RemoveRangeSwapBackWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt64Insert()
    {
        var list = new FixedListInt64() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt64Sort()
    {
        var list = new FixedListInt64();
        for(var i = 0; i < 5; ++i)
          list.Add((int)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt64ToFixedListInt32()
    {
        var a = new FixedListInt64();
        for(var i = 0; i < 15; ++i)
            a.Add((int)i);
        Assert.Throws<IndexOutOfRangeException> (() => { var b = new FixedListInt32(a); } );
    }
    [Test]
    public void FixedListInt64ToFixedListInt128()
    {
        var a = new FixedListInt64();
        for(var i = 0; i < 15; ++i)
            a.Add((int)i);
        var b = new FixedListInt128(a);
        for(var i = 0; i < 15; ++i)
            Assert.AreEqual((int)i, b[i]);
    }

    [Test]
    public void FixedListInt128HasExpectedLayout()
    {
        var actual = new FixedListInt128();
        for(var i = 0; i < 31; ++i)
          actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((31 >> 0) & 0xFF);
            e[1] = (byte)((31 >> 8) & 0xFF);
            for(var i = 0; i < 31; ++i)
            {
              var s = (int)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedListInt128HasExpectedCapacity()
    {
        var list = new FixedListInt128();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((int)expectedCapacity); });
    }

#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
    class ScriptableObjectFixedListInt128 : UnityEngine.ScriptableObject
    {
        public FixedListInt128 List;
    }

    [Test]
    public void FixedListInt128Serializes()
    {
        var a = UnityEngine.ScriptableObject.CreateInstance<ScriptableObjectFixedListInt128 >();
        for(int i = 0; i < a.List.Capacity; ++i)
            a.List.Add((int)i);
        var b = UnityEngine.Object.Instantiate(a);
        CollectionAssert.AreEqual(a.List, b.List);
    }
#endif

    [Test]
    public void FixedListInt128InsertRangeWithBeginEnd()
    {
        var list = new FixedListInt128() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListInt128 container, int expectedLength, int[] expected)
    {
        Assert.AreEqual(expectedLength == 0, container.IsEmpty);
        Assert.AreEqual(container.Length, expectedLength);
        for (var i = 0; i < container.Length; ++i)
        {
            Assert.AreEqual(expected[i], container[i]);
        }
    }

    [Test]
    public void FixedListInt128RemoveAt()
    {
        var list = new FixedListInt128() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt128Remove()
    {
        var list = new FixedListInt128() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove(3));
        Assert.True(list.Remove(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt128RemoveSwapBack()
    {
        var list = new FixedListInt128() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack(3));
        Assert.True(list.RemoveSwapBack(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt128RemoveRangeWithBeginEnd()
    {
        var list = new FixedListInt128() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt128RemoveAtSwapBack()
    {
        var list = new FixedListInt128() { 0, 3, 3, 1, 2 };
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListInt128RemoveRangeSwapBackWithBeginEnd()
    {
        var list = new FixedListInt128() { 0, 3, 3, 1, 2 };
        list.RemoveRangeSwapBackWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt128Insert()
    {
        var list = new FixedListInt128() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt128Sort()
    {
        var list = new FixedListInt128();
        for(var i = 0; i < 5; ++i)
          list.Add((int)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt128ToFixedListInt32()
    {
        var a = new FixedListInt128();
        for(var i = 0; i < 31; ++i)
            a.Add((int)i);
        Assert.Throws<IndexOutOfRangeException> (() => { var b = new FixedListInt32(a); } );
    }
    [Test]
    public void FixedListInt128ToFixedListInt64()
    {
        var a = new FixedListInt128();
        for(var i = 0; i < 31; ++i)
            a.Add((int)i);
        Assert.Throws<IndexOutOfRangeException> (() => { var b = new FixedListInt64(a); } );
    }

    [Test]
    public void FixedList32floatToNativeArrayWorks()
    {
        var list = new FixedList32<float>();

        for(var i = 0; i < 7; ++i)
            list.Add((float)(i * 123 + 234));

        using(var array = list.ToNativeArray(Allocator.Temp))
        {
            for(var i = 0; i < 7; ++i)
                Assert.AreEqual((float)(i * 123 + 234), array[i]);
        }
    }

    [Test]
    public void FixedList32floatGenericHasExpectedLayout()
    {
        var actual = new FixedList32<float>();
        for(var i = 0; i < 7; ++i)
          actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((7 >> 0) & 0xFF);
            e[1] = (byte)((7 >> 8) & 0xFF);
            for(var i = 0; i < 7; ++i)
            {
              var s = (float)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedList32floatGenericHasExpectedCapacity()
    {
        var list = new FixedList32<float>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((float)expectedCapacity); });
    }
    [Test]
    public void FixedList32floatGenericInsertRangeWithBeginEnd()
    {
        var list = new FixedList32<float>() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericRemoveRangeWithBeginEnd()
    {
        var list = new FixedList32<float>() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericInsert()
    {
        var list = new FixedList32<float>() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericRemoveAt()
    {
        var list = new FixedList32<float>() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericRemove()
    {
        var list = new FixedList32<float>() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove((float)3));
        Assert.True(list.Remove((float)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericRemoveSwapBack()
    {
        var list = new FixedList32<float>() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack((float)3));
        Assert.True(list.RemoveSwapBack((float)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericSort()
    {
        var list = new FixedList32<float>();
        for(var i = 0; i < 5; ++i)
          list.Add((float)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericSortCustomComparer()
    {
        var list = new FixedList32<float>();
        for(var i = 0; i < 5; ++i)
          list.Add((float)(i));
        list.Sort(new DescendingComparer<float>());
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(4-i, list[i]);
    }

    [Test]
    public unsafe void FixedList32floatIndexOf()
    {
        var list = new FixedList32<float>() { 123, 178 };
        bool r0 = false, r1 = false, r2 = false;

        GCAllocRecorder.ValidateNoGCAllocs(() =>
        {
            r0 = -1 != list.IndexOf((float)145);
            r1 = list.Contains((float)123);
            r2 = list.Contains((float)178);
        });

        Assert.False(r0);
        Assert.True(r1);
        Assert.True(r2);
    }


    [Test]
    public void FixedList64floatToNativeArrayWorks()
    {
        var list = new FixedList64<float>();

        for(var i = 0; i < 15; ++i)
            list.Add((float)(i * 123 + 234));

        using(var array = list.ToNativeArray(Allocator.Temp))
        {
            for(var i = 0; i < 15; ++i)
                Assert.AreEqual((float)(i * 123 + 234), array[i]);
        }
    }

    [Test]
    public void FixedList64floatGenericHasExpectedLayout()
    {
        var actual = new FixedList64<float>();
        for(var i = 0; i < 15; ++i)
          actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((15 >> 0) & 0xFF);
            e[1] = (byte)((15 >> 8) & 0xFF);
            for(var i = 0; i < 15; ++i)
            {
              var s = (float)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedList64floatGenericHasExpectedCapacity()
    {
        var list = new FixedList64<float>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((float)expectedCapacity); });
    }
    [Test]
    public void FixedList64floatGenericInsertRangeWithBeginEnd()
    {
        var list = new FixedList64<float>() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericRemoveRangeWithBeginEnd()
    {
        var list = new FixedList64<float>() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericInsert()
    {
        var list = new FixedList64<float>() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericRemoveAt()
    {
        var list = new FixedList64<float>() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericRemove()
    {
        var list = new FixedList64<float>() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove((float)3));
        Assert.True(list.Remove((float)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericRemoveSwapBack()
    {
        var list = new FixedList64<float>() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack((float)3));
        Assert.True(list.RemoveSwapBack((float)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericSort()
    {
        var list = new FixedList64<float>();
        for(var i = 0; i < 5; ++i)
          list.Add((float)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericSortCustomComparer()
    {
        var list = new FixedList64<float>();
        for(var i = 0; i < 5; ++i)
          list.Add((float)(i));
        list.Sort(new DescendingComparer<float>());
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(4-i, list[i]);
    }

    [Test]
    public unsafe void FixedList64floatIndexOf()
    {
        var list = new FixedList64<float>() { 123, 178 };
        bool r0 = false, r1 = false, r2 = false;

        GCAllocRecorder.ValidateNoGCAllocs(() =>
        {
            r0 = -1 != list.IndexOf((float)145);
            r1 = list.Contains((float)123);
            r2 = list.Contains((float)178);
        });

        Assert.False(r0);
        Assert.True(r1);
        Assert.True(r2);
    }


    [Test]
    public void FixedList128floatToNativeArrayWorks()
    {
        var list = new FixedList128<float>();

        for(var i = 0; i < 31; ++i)
            list.Add((float)(i * 123 + 234));

        using(var array = list.ToNativeArray(Allocator.Temp))
        {
            for(var i = 0; i < 31; ++i)
                Assert.AreEqual((float)(i * 123 + 234), array[i]);
        }
    }

    [Test]
    public void FixedList128floatGenericHasExpectedLayout()
    {
        var actual = new FixedList128<float>();
        for(var i = 0; i < 31; ++i)
          actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((31 >> 0) & 0xFF);
            e[1] = (byte)((31 >> 8) & 0xFF);
            for(var i = 0; i < 31; ++i)
            {
              var s = (float)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedList128floatGenericHasExpectedCapacity()
    {
        var list = new FixedList128<float>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((float)expectedCapacity); });
    }
    [Test]
    public void FixedList128floatGenericInsertRangeWithBeginEnd()
    {
        var list = new FixedList128<float>() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericRemoveRangeWithBeginEnd()
    {
        var list = new FixedList128<float>() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericInsert()
    {
        var list = new FixedList128<float>() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericRemoveAt()
    {
        var list = new FixedList128<float>() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericRemove()
    {
        var list = new FixedList128<float>() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove((float)3));
        Assert.True(list.Remove((float)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericRemoveSwapBack()
    {
        var list = new FixedList128<float>() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack((float)3));
        Assert.True(list.RemoveSwapBack((float)3));
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericSort()
    {
        var list = new FixedList128<float>();
        for(var i = 0; i < 5; ++i)
          list.Add((float)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericSortCustomComparer()
    {
        var list = new FixedList128<float>();
        for(var i = 0; i < 5; ++i)
          list.Add((float)(i));
        list.Sort(new DescendingComparer<float>());
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(4-i, list[i]);
    }

    [Test]
    public unsafe void FixedList128floatIndexOf()
    {
        var list = new FixedList128<float>() { 123, 178 };
        bool r0 = false, r1 = false, r2 = false;

        GCAllocRecorder.ValidateNoGCAllocs(() =>
        {
            r0 = -1 != list.IndexOf((float)145);
            r1 = list.Contains((float)123);
            r2 = list.Contains((float)178);
        });

        Assert.False(r0);
        Assert.True(r1);
        Assert.True(r2);
    }


    [Test]
    public void FixedListFloat32HasExpectedLayout()
    {
        var actual = new FixedListFloat32();
        for(var i = 0; i < 7; ++i)
          actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((7 >> 0) & 0xFF);
            e[1] = (byte)((7 >> 8) & 0xFF);
            for(var i = 0; i < 7; ++i)
            {
              var s = (float)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedListFloat32HasExpectedCapacity()
    {
        var list = new FixedListFloat32();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((float)expectedCapacity); });
    }

#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
    class ScriptableObjectFixedListFloat32 : UnityEngine.ScriptableObject
    {
        public FixedListFloat32 List;
    }

    [Test]
    public void FixedListFloat32Serializes()
    {
        var a = UnityEngine.ScriptableObject.CreateInstance<ScriptableObjectFixedListFloat32 >();
        for(int i = 0; i < a.List.Capacity; ++i)
            a.List.Add((float)i);
        var b = UnityEngine.Object.Instantiate(a);
        CollectionAssert.AreEqual(a.List, b.List);
    }
#endif

    [Test]
    public void FixedListFloat32InsertRangeWithBeginEnd()
    {
        var list = new FixedListFloat32() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListFloat32 container, int expectedLength, int[] expected)
    {
        Assert.AreEqual(expectedLength == 0, container.IsEmpty);
        Assert.AreEqual(container.Length, expectedLength);
        for (var i = 0; i < container.Length; ++i)
        {
            Assert.AreEqual(expected[i], container[i]);
        }
    }

    [Test]
    public void FixedListFloat32RemoveAt()
    {
        var list = new FixedListFloat32() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat32Remove()
    {
        var list = new FixedListFloat32() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove(3));
        Assert.True(list.Remove(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat32RemoveSwapBack()
    {
        var list = new FixedListFloat32() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack(3));
        Assert.True(list.RemoveSwapBack(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat32RemoveRangeWithBeginEnd()
    {
        var list = new FixedListFloat32() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat32RemoveAtSwapBack()
    {
        var list = new FixedListFloat32() { 0, 3, 3, 1, 2 };
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListFloat32RemoveRangeSwapBackWithBeginEnd()
    {
        var list = new FixedListFloat32() { 0, 3, 3, 1, 2 };
        list.RemoveRangeSwapBackWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat32Insert()
    {
        var list = new FixedListFloat32() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat32Sort()
    {
        var list = new FixedListFloat32();
        for(var i = 0; i < 5; ++i)
          list.Add((float)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat32ToFixedListFloat64()
    {
        var a = new FixedListFloat32();
        for(var i = 0; i < 7; ++i)
            a.Add((float)i);
        var b = new FixedListFloat64(a);
        for(var i = 0; i < 7; ++i)
            Assert.AreEqual((float)i, b[i]);
    }
    [Test]
    public void FixedListFloat32ToFixedListFloat128()
    {
        var a = new FixedListFloat32();
        for(var i = 0; i < 7; ++i)
            a.Add((float)i);
        var b = new FixedListFloat128(a);
        for(var i = 0; i < 7; ++i)
            Assert.AreEqual((float)i, b[i]);
    }

    [Test]
    public void FixedListFloat64HasExpectedLayout()
    {
        var actual = new FixedListFloat64();
        for(var i = 0; i < 15; ++i)
          actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((15 >> 0) & 0xFF);
            e[1] = (byte)((15 >> 8) & 0xFF);
            for(var i = 0; i < 15; ++i)
            {
              var s = (float)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedListFloat64HasExpectedCapacity()
    {
        var list = new FixedListFloat64();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((float)expectedCapacity); });
    }

#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
    class ScriptableObjectFixedListFloat64 : UnityEngine.ScriptableObject
    {
        public FixedListFloat64 List;
    }

    [Test]
    public void FixedListFloat64Serializes()
    {
        var a = UnityEngine.ScriptableObject.CreateInstance<ScriptableObjectFixedListFloat64 >();
        for(int i = 0; i < a.List.Capacity; ++i)
            a.List.Add((float)i);
        var b = UnityEngine.Object.Instantiate(a);
        CollectionAssert.AreEqual(a.List, b.List);
    }
#endif

    [Test]
    public void FixedListFloat64InsertRangeWithBeginEnd()
    {
        var list = new FixedListFloat64() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListFloat64 container, int expectedLength, int[] expected)
    {
        Assert.AreEqual(expectedLength == 0, container.IsEmpty);
        Assert.AreEqual(container.Length, expectedLength);
        for (var i = 0; i < container.Length; ++i)
        {
            Assert.AreEqual(expected[i], container[i]);
        }
    }

    [Test]
    public void FixedListFloat64RemoveAt()
    {
        var list = new FixedListFloat64() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat64Remove()
    {
        var list = new FixedListFloat64() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove(3));
        Assert.True(list.Remove(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat64RemoveSwapBack()
    {
        var list = new FixedListFloat64() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack(3));
        Assert.True(list.RemoveSwapBack(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat64RemoveRangeWithBeginEnd()
    {
        var list = new FixedListFloat64() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat64RemoveAtSwapBack()
    {
        var list = new FixedListFloat64() { 0, 3, 3, 1, 2 };
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListFloat64RemoveRangeSwapBackWithBeginEnd()
    {
        var list = new FixedListFloat64() { 0, 3, 3, 1, 2 };
        list.RemoveRangeSwapBackWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat64Insert()
    {
        var list = new FixedListFloat64() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat64Sort()
    {
        var list = new FixedListFloat64();
        for(var i = 0; i < 5; ++i)
          list.Add((float)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat64ToFixedListFloat32()
    {
        var a = new FixedListFloat64();
        for(var i = 0; i < 15; ++i)
            a.Add((float)i);
        Assert.Throws<IndexOutOfRangeException> (() => { var b = new FixedListFloat32(a); } );
    }
    [Test]
    public void FixedListFloat64ToFixedListFloat128()
    {
        var a = new FixedListFloat64();
        for(var i = 0; i < 15; ++i)
            a.Add((float)i);
        var b = new FixedListFloat128(a);
        for(var i = 0; i < 15; ++i)
            Assert.AreEqual((float)i, b[i]);
    }

    [Test]
    public void FixedListFloat128HasExpectedLayout()
    {
        var actual = new FixedListFloat128();
        for(var i = 0; i < 31; ++i)
          actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((31 >> 0) & 0xFF);
            e[1] = (byte)((31 >> 8) & 0xFF);
            for(var i = 0; i < 31; ++i)
            {
              var s = (float)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedListFloat128HasExpectedCapacity()
    {
        var list = new FixedListFloat128();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((float)expectedCapacity); });
    }

#if !UNITY_DOTSRUNTIME        // DOTS-Runtime doesn't support UnityEngine
    class ScriptableObjectFixedListFloat128 : UnityEngine.ScriptableObject
    {
        public FixedListFloat128 List;
    }

    [Test]
    public void FixedListFloat128Serializes()
    {
        var a = UnityEngine.ScriptableObject.CreateInstance<ScriptableObjectFixedListFloat128 >();
        for(int i = 0; i < a.List.Capacity; ++i)
            a.List.Add((float)i);
        var b = UnityEngine.Object.Instantiate(a);
        CollectionAssert.AreEqual(a.List, b.List);
    }
#endif

    [Test]
    public void FixedListFloat128InsertRangeWithBeginEnd()
    {
        var list = new FixedListFloat128() { 0, 3, 4 };
        list.InsertRangeWithBeginEnd(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListFloat128 container, int expectedLength, int[] expected)
    {
        Assert.AreEqual(expectedLength == 0, container.IsEmpty);
        Assert.AreEqual(container.Length, expectedLength);
        for (var i = 0; i < container.Length; ++i)
        {
            Assert.AreEqual(expected[i], container[i]);
        }
    }

    [Test]
    public void FixedListFloat128RemoveAt()
    {
        var list = new FixedListFloat128() { 0, 3, 3, 1, 2 };
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat128Remove()
    {
        var list = new FixedListFloat128() { 0, 3, 3, 1, 2 };
        Assert.True(list.Remove(3));
        Assert.True(list.Remove(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat128RemoveSwapBack()
    {
        var list = new FixedListFloat128() { 0, 3, 3, 2, 1 };
        Assert.True(list.RemoveSwapBack(3));
        Assert.True(list.RemoveSwapBack(3));
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat128RemoveRangeWithBeginEnd()
    {
        var list = new FixedListFloat128() { 0, 3, 3, 1, 2 };
        list.RemoveRangeWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat128RemoveAtSwapBack()
    {
        var list = new FixedListFloat128() { 0, 3, 3, 1, 2 };
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListFloat128RemoveRangeSwapBackWithBeginEnd()
    {
        var list = new FixedListFloat128() { 0, 3, 3, 1, 2 };
        list.RemoveRangeSwapBackWithBeginEnd(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat128Insert()
    {
        var list = new FixedListFloat128() { 0, 3, 4 };
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat128Sort()
    {
        var list = new FixedListFloat128();
        for(var i = 0; i < 5; ++i)
          list.Add((float)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat128ToFixedListFloat32()
    {
        var a = new FixedListFloat128();
        for(var i = 0; i < 31; ++i)
            a.Add((float)i);
        Assert.Throws<IndexOutOfRangeException> (() => { var b = new FixedListFloat32(a); } );
    }
    [Test]
    public void FixedListFloat128ToFixedListFloat64()
    {
        var a = new FixedListFloat128();
        for(var i = 0; i < 31; ++i)
            a.Add((float)i);
        Assert.Throws<IndexOutOfRangeException> (() => { var b = new FixedListFloat64(a); } );
    }

}
