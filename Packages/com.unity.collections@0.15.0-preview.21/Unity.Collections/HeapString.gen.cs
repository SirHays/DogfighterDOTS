
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/HeapString.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.Internal;
#if UNITY_PROPERTIES_EXISTS
using Unity.Properties;
#endif



namespace Unity.Collections
{
    /// <summary>
    /// An unmanaged string in UTF-8 format that maintains a variable-length allocated inner buffer.
    /// The string is guaranteed to be null-terminated, at the byte at the current Length offset.
    /// This structure is a native collection, and as such requires creating with an allocator
    /// and requires being disposed.
    /// </summary>
    [BurstCompatible]
    public partial struct HeapString
        : INativeList<byte>
        , IDisposable
        , IUTF8Bytes
        , IComparable<String>
        , IEquatable<String>
        , IComparable<HeapString>
        , IEquatable<HeapString>
        , IComparable<FixedString32>
        , IEquatable<FixedString32>
        , IComparable<FixedString64>
        , IEquatable<FixedString64>
        , IComparable<FixedString128>
        , IEquatable<FixedString128>
        , IComparable<FixedString512>
        , IEquatable<FixedString512>
        , IComparable<FixedString4096>
        , IEquatable<FixedString4096>
    {
        // NOTE! This Length is always > 0, because we have a null terminating byte.
        // We hide this byte from HeapString users.
        private NativeList<byte> m_Data;

        /// <summary>
        /// The current length of the UTF-8 encoded string, in bytes. The string is guaranteed to be
        /// null-terminated. The length value does not include the null terminating byte. It is valid to
        /// read the null byte at the Length position when accessing this data by raw pointer.
        /// </summary>
        public int Length
        {
            get {
                return m_Data.Length - 1;
            }
            set {
                m_Data.Resize(value + 1, NativeArrayOptions.UninitializedMemory);
                m_Data[value] = 0;
            }
        }

        /// <summary>
        /// The current capacity of this HeapString.  Setting this value may cause the underlying buffer
        /// to be reallocated.
        /// </summary>
        public int Capacity
        {
            get {
                return m_Data.Capacity - 1;
            }
            set {
                m_Data.Capacity = value + 1;
            }
        }

        /// <summary>
        /// Attempt to set the length of the string, in UTF-8 bytes.
        /// </summary>
        /// <param name="newLength">The new length of the string</param>
        /// <param name="clearOptions">Whether the new memory should be initialized or not</param>
        /// <returns>Whether the resize was successful.</returns>
        public bool TryResize(int newLength, NativeArrayOptions clearOptions = NativeArrayOptions.ClearMemory)
        {
            // this can't ever fail, because if we can't resize malloc will abort
            Length = newLength;
            return true;
        }

        /// <summary>
        /// Reports whether container is empty.
        /// </summary>
        /// <value>True if this container empty.</value>
        public bool IsEmpty => m_Data.Length == 1;

        /// <summary>
        /// Reports whether memory for the container is allocated.
        /// </summary>
        /// <value>True if this container object's internal storage has been allocated.</value>
        /// <remarks>
        /// Note that the container storage is not created if you use the default constructor. You must specify
        /// at least an allocation type to construct a usable container.
        ///
        /// *Warning:* the `IsCreated` property can't be used to determine whether a copy of a container is still valid.
        /// If you dispose any copy of the container, the container storage is deallocated. However, the properties of
        /// the other copies of the container (including the original) are not updated. As a result the `IsCreated` property
        /// of the copies still return `true` even though the container storage has been deallocated.
        /// Accessing the data of a native container that has been disposed throws a <see cref='InvalidOperationException'/> exception.
        /// </remarks>
        public bool IsCreated => m_Data.IsCreated;

        /// <summary>
        /// Returns a pointer to the underlying byte stream.  This pointer will become invalid if the underlying
        /// allocation is changed, such as by changing the Capacity or adding any data to the HeapString.
        /// </summary>
        public unsafe byte* GetUnsafePtr()
        {
            return (byte*) m_Data.GetUnsafePtr();
        }

        /// <summary>
        /// Return the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length)
        /// </summary>
        public byte this[int index]
        {
            get {
                CheckIndexInRange(index);
                return m_Data[index];
            }
            set {
                CheckIndexInRange(index);
                m_Data[index] = value;
            }
        }

        /// <summary>
        /// Return a ref to the the byte at the given byte (not character) index.  The index
        /// must be in the range of [0..Length).  The ref byte is a direct reference into
        /// this HeapString, and is only valid while this HeapString's underlying allocation doesn't change.
        /// </summary>
        /// <param name="index">The byte index to access</param>
        /// <returns>A ref byte for the requested index</returns>
        public ref byte ElementAt(int index)
        {
            CheckIndexInRange(index);
            return ref m_Data.ElementAt(index);
        }

        /// <summary>
        /// Clear this string by setting its Length to 0.
        /// </summary>
        public void Clear()
        {
            m_Data.Clear();
        }

        /// <summary>
        /// Append the given byte value to this string. The string will remain null-terminated after the new
        /// byte. Appending an invalid UTF-8 sequence will cause the contents of this string to be invalid when
        /// converted to UTF-16 or UCS-2. No validation of the appended bytes is done.
        /// </summary>
        /// <param name="value">The byte to append.</param>
        public void Add(in byte value)
        {
            this[Length++] = value;
        }

        /// <summary>
        /// Compare this HeapString with another in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The HeapString to compare with</param>
        /// <returns>
        /// negative value if this HeapString would appear first if sorted,
        ///  0 if they are identical, or
        /// positive value if the other HeapString would appear first if sorted.
        /// </returns>
        public int CompareTo(HeapString other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Compare this HeapString with another, and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The HeapString to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(HeapString other)
        {
            return FixedStringMethods.Equals(ref this, other);
        }

        /// <summary>
        /// Dispose this HeapString's underlying allocation.
        /// </summary>
        public void Dispose()
        {
            m_Data.Dispose();
        }

        /// <summary>
        /// A property in order to display the value in Unity.Properties generated UI.
        /// </summary>
        [CreateProperty]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        [NotBurstCompatible]
        public string Value => ToString();

        /// <summary>
        /// <undoc />
        /// </summary>
        public struct Enumerator : IEnumerator<Unicode.Rune>
        {
            HeapString target;
            int offset;
            Unicode.Rune current;

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <param name="source"><undoc /></param>
            public Enumerator(HeapString source)
            {
                target = source;
                offset = 0;
                current = default;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Dispose()
            {
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            /// <returns><undoc /></returns>
            public bool MoveNext()
            {
                if (offset >= target.Length)
                    return false;

                unsafe
                {
                    Unicode.Utf8ToUcs(out current, target.GetUnsafePtr(), ref offset, target.Length);
                }

                return true;
            }

            /// <summary>
            /// <undoc />
            /// </summary>
            public void Reset()
            {
                offset = 0;
                current = default;
            }

            object IEnumerator.Current => Current;

            /// <summary>
            /// <undoc />
            /// </summary>
            public Unicode.Rune Current => current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Compare this HeapString with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this HeapString would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        [NotBurstCompatible]
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this HeapString with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        [NotBurstCompatible]
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Construct a HeapString from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this HeapString with</param>
        /// <param name="allocator">the Allocator to use for the underlying memory</param>
        public HeapString(String source, Allocator allocator)
        {
            m_Data = new NativeList<byte>(source.Length * 2 + 1, allocator);
            Length = source.Length * 2; // maximum possible
            unsafe
            {
                fixed (char* sourceptr = source)
                {
                    var error = UTF8ArrayUnsafeUtility.Copy(GetUnsafePtr(), out var actualBytes, Capacity, sourceptr, source.Length);
                    if (error != CopyError.None)
                    {
                        m_Data.Dispose();
                        m_Data = default;
                        ThrowCopyError(error, source);
                    }
                    this.Length = actualBytes;
                }
            }
        }

        /// <summary>
        /// Construct an empty HeapString with the given capacity.
        /// </summary>
        /// <param name="capacity">the initial capacity, in bytes</param>
        /// <param name="allocator">the Allocator to use for the underlying memory</param>
        public HeapString(int capacity, Allocator allocator)
        {
            m_Data = new NativeList<byte>(capacity + 1, allocator);
            this.Length = 0;
        }

        /// <summary>
        /// Construct an empty HeapString with a default capacity of 512 bytes.
        /// </summary>
        /// <param name="allocator">the Allocator to use for the underlying memory</param>
        public HeapString(Allocator allocator)
        {
            m_Data = new NativeList<byte>(128 + 1, allocator);
            this.Length = 0;
        }

        /// <summary>
        /// Compare this HeapString with a FixedString32 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this HeapString would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString32 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString32 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a HeapString by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="allocator">the Allocator to use for the underlying memory</param>
        public HeapString(in FixedString32 source, Allocator allocator)
        {
            m_Data = new NativeList<byte>(source.utf8LengthInBytes + 1, allocator);
            Length = source.utf8LengthInBytes;

            unsafe {
                byte* sbytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                byte* dbytes = (byte*) m_Data.GetUnsafePtr();
                UnsafeUtility.MemCpy(dbytes, sbytes, source.utf8LengthInBytes);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in HeapString a, in FixedString32 b)
        {
            unsafe {
                var aref = UnsafeUtilityExtensions.AsRef(a);
                int alen = aref.Length;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) aref.GetUnsafePtr();
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in HeapString a, in FixedString32 b)
        {
            return !(a == b);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString32 other)
        {
            return this == other;
        }
        /// <summary>
        /// Compare this HeapString with a FixedString64 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this HeapString would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString64 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString64 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a HeapString by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="allocator">the Allocator to use for the underlying memory</param>
        public HeapString(in FixedString64 source, Allocator allocator)
        {
            m_Data = new NativeList<byte>(source.utf8LengthInBytes + 1, allocator);
            Length = source.utf8LengthInBytes;

            unsafe {
                byte* sbytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                byte* dbytes = (byte*) m_Data.GetUnsafePtr();
                UnsafeUtility.MemCpy(dbytes, sbytes, source.utf8LengthInBytes);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in HeapString a, in FixedString64 b)
        {
            unsafe {
                var aref = UnsafeUtilityExtensions.AsRef(a);
                int alen = aref.Length;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) aref.GetUnsafePtr();
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in HeapString a, in FixedString64 b)
        {
            return !(a == b);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString64 other)
        {
            return this == other;
        }
        /// <summary>
        /// Compare this HeapString with a FixedString128 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this HeapString would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString128 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString128 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a HeapString by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="allocator">the Allocator to use for the underlying memory</param>
        public HeapString(in FixedString128 source, Allocator allocator)
        {
            m_Data = new NativeList<byte>(source.utf8LengthInBytes + 1, allocator);
            Length = source.utf8LengthInBytes;

            unsafe {
                byte* sbytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                byte* dbytes = (byte*) m_Data.GetUnsafePtr();
                UnsafeUtility.MemCpy(dbytes, sbytes, source.utf8LengthInBytes);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in HeapString a, in FixedString128 b)
        {
            unsafe {
                var aref = UnsafeUtilityExtensions.AsRef(a);
                int alen = aref.Length;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) aref.GetUnsafePtr();
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in HeapString a, in FixedString128 b)
        {
            return !(a == b);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString128 other)
        {
            return this == other;
        }
        /// <summary>
        /// Compare this HeapString with a FixedString512 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this HeapString would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString512 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString512 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a HeapString by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="allocator">the Allocator to use for the underlying memory</param>
        public HeapString(in FixedString512 source, Allocator allocator)
        {
            m_Data = new NativeList<byte>(source.utf8LengthInBytes + 1, allocator);
            Length = source.utf8LengthInBytes;

            unsafe {
                byte* sbytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                byte* dbytes = (byte*) m_Data.GetUnsafePtr();
                UnsafeUtility.MemCpy(dbytes, sbytes, source.utf8LengthInBytes);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in HeapString a, in FixedString512 b)
        {
            unsafe {
                var aref = UnsafeUtilityExtensions.AsRef(a);
                int alen = aref.Length;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) aref.GetUnsafePtr();
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in HeapString a, in FixedString512 b)
        {
            return !(a == b);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString512 other)
        {
            return this == other;
        }
        /// <summary>
        /// Compare this HeapString with a FixedString4096 in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The FixedString to compare with</param>
        /// <returns>
        /// -1 if this HeapString would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other FixedString4096 would appear first if sorted.
        /// </returns>
        public int CompareTo(FixedString4096 other)
        {
            return FixedStringMethods.CompareTo(ref this, other);
        }

        /// <summary>
        /// Construct a HeapString by copying from another FixedString source.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="allocator">the Allocator to use for the underlying memory</param>
        public HeapString(in FixedString4096 source, Allocator allocator)
        {
            m_Data = new NativeList<byte>(source.utf8LengthInBytes + 1, allocator);
            Length = source.utf8LengthInBytes;

            unsafe {
                byte* sbytes = (byte*) UnsafeUtilityExtensions.AddressOf(source.bytes);
                byte* dbytes = (byte*) m_Data.GetUnsafePtr();
                UnsafeUtility.MemCpy(dbytes, sbytes, source.utf8LengthInBytes);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator ==(in HeapString a, in FixedString4096 b)
        {
            unsafe {
                var aref = UnsafeUtilityExtensions.AsRef(a);
                int alen = aref.Length;
                int blen = b.utf8LengthInBytes;
                byte* aptr = (byte*) aref.GetUnsafePtr();
                byte* bptr = (byte*) UnsafeUtilityExtensions.AddressOf(b.bytes);
                return UTF8ArrayUnsafeUtility.EqualsUTF8Bytes(aptr, alen, bptr, blen);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool operator !=(in HeapString a, in FixedString4096 b)
        {
            return !(a == b);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(FixedString4096 other)
        {
            return this == other;
        }

        /// <summary>
        /// Convert this HeapString to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this HeapString</returns>
        [NotBurstCompatible]
        public override String ToString()
        {
            if (!m_Data.IsCreated)
                return "";
            return this.ConvertToString();
        }

        /// <summary>
        /// Compute a hash code of this HeapString: an integer that is likely to be different for
        /// two HeapString, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this HeapString</returns>
        public override int GetHashCode()
        {
            return this.ComputeHashCode();
        }

        /// <summary>
        /// Determines whether a HeapString has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        /// <returns></returns>
        [NotBurstCompatible]
        public override bool Equals(object obj)
        {
            if(ReferenceEquals(null, obj)) return false;
            if(obj is String aString) return Equals(aString);
            if(obj is HeapString aHeapString) return Equals(aHeapString);
            if(obj is FixedString32 a32) return Equals(a32);
            if(obj is FixedString64 a64) return Equals(a64);
            if(obj is FixedString128 a128) return Equals(a128);
            if(obj is FixedString512 a512) return Equals(a512);
            if(obj is FixedString4096 a4096) return Equals(a4096);
            return false;
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= Length)
                throw new IndexOutOfRangeException($"Index {index} is out of range in HeapString of {Length} length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        void ThrowCopyError(CopyError error, String source)
        {
            throw new ArgumentException($"HeapString: {error} while copying \"{source}\"");
        }
    }
}
