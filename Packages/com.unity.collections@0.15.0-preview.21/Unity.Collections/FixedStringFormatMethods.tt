<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ template debug="True" #>
<#@ output extension=".gen.cs" encoding="utf-8" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/FixedStringFormatMethods.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.Collections
{
    /// <summary>
    /// <undoc />
    /// </summary>
    public unsafe static partial class FixedStringMethods
    {
<#
    for (var ARGS = 1; ARGS <= 10; ++ARGS)
    {
        var TYPES    = String.Join(", ", Enumerable.Range(0, ARGS).Select(n => $"T{n}"));
        var PARAMS   = String.Join(", ", Enumerable.Range(0, ARGS).Select(n => $"in T{n} arg{n}"));
        var ARGNAMES = String.Join(", ", Enumerable.Range(0, ARGS).Select(n => $"arg{n}"));
        var TxDOCS   = String.Join("\r\n        /// ", Enumerable.Range(0, ARGS).Select(n => $"<typeparam name=\"T{n}\"><undoc /></typeparam>"));
        var ARGxDOCS = String.Join("\r\n        /// ", Enumerable.Range(0, ARGS).Select(n => $"<param name=\"arg{n}\"><undoc /></param>"));
        var BCOMPAT  = String.Join(", ", Enumerable.Range(0, ARGS).Select(n => $"typeof(FixedString128 /*T{n}*/)"));
#>
        /// <summary>
        /// Convenience function to append a formatted string into the given FixedString.
        /// Similar to StringBuilder.AppendFormat, with significant limitations:
        ///   - only supports FixedStringN arguments (convert arguments to FixedString first)
        ///   - only supports numeric format placeholders of the form "{0}" .. "{N}"
        ///   - no format modifiers (e.g. "{0:x}") are supported
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="U"></typeparam>
        /// <#=TxDOCS#>
        /// <param name="dest"></param>
        /// <param name="format"></param>
        /// <#=ARGxDOCS#>
        [BurstCompatible(GenericTypeArguments = new[] { typeof(FixedString128 /*T*/), typeof(FixedString128 /*U*/), <#=BCOMPAT#> })]
        public static unsafe void AppendFormat<T, U, <#=TYPES#>>(ref this T dest, in U format, <#=PARAMS#>)
            where T : struct, INativeList<byte>, IUTF8Bytes
            where U : struct, INativeList<byte>, IUTF8Bytes
<#
        for (var a = 0; a < ARGS; ++a)
            WriteLine("            where T{0} : struct, INativeList<byte>, IUTF8Bytes", a);
#>
        {
            ref var formatRef = ref UnsafeUtilityExtensions.AsRef(in format);
            int formatLength = formatRef.Length;
            byte* formatBytes = formatRef.GetUnsafePtr();
            for (var i = 0; i < formatLength; ++i)
            {
                if (formatBytes[i] == (byte)'{')
                {
                    if (formatLength - i >= 3 && formatBytes[i + 1] != (byte)'{')
                    {
                        var index = formatBytes[i + 1] - (byte)'0';
                        switch (index)
                        {
<#
        for(var a = 0; a < ARGS; ++a)
        {
            WriteLine($"                            case {a}: dest.Append(in arg{a}); i+=2; break;");
        }
#>
                            default:
                                dest.AppendRawByte(formatBytes[i]);
                                break;
                        }
                    }
                }
                else
                    dest.AppendRawByte(formatBytes[i]);
            }
        }

<#
    }
#>

    }
}
